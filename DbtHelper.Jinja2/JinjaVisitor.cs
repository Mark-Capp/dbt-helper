using System.Text;namespace DbtHelper.Jinja2;internal class JinjaVisitor : JinjaParserBaseVisitor<List<Block>>{    public override List<Block> VisitProgram(JinjaParser.ProgramContext context)    {        var blocks = new List<Block>();                var visitor = new ExpressionVisitor();        var statements = context.statement();        foreach (var statement in statements)             blocks.AddRange(visitor.Visit(statement));                return blocks;    }}internal class ExpressionVisitor : JinjaParserBaseVisitor<Block>{    public override Block VisitAssignment_statement(JinjaParser.Assignment_statementContext context)    {        var name = context.ID().GetText();        var expression = Visit(context.expression()) as ExpressionBlock;        return new AssignmentBlock(name, expression!);    }    public override Block VisitEvaluation_statement(JinjaParser.Evaluation_statementContext context)    {        var expression = Visit(context.expression()) as ExpressionBlock;        return new EvaluationBlock(expression!);    }    public override Block VisitEqAdd(JinjaParser.EqAddContext context)    {        var left = Visit(context.left) as ExpressionBlock;        var right = Visit(context.right) as ExpressionBlock;        if (left == null || right == null)        {            return null;        }        return new AddSubExpressionBlock(left, right, context.@operator.Type == JinjaParser.ADD ? Operator.Add :            Operator.Subtract);    }    public override Block VisitEqMUL(JinjaParser.EqMULContext context)    {        var left = Visit(context.left) as ExpressionBlock;        var right = Visit(context.right) as ExpressionBlock;        if (left == null || right == null)        {            return null;        }        return new AddSubExpressionBlock(left, right, context.@operator.Type == JinjaParser.MUL ? Operator.Mul :            Operator.Div);    }    public override Block VisitBody(JinjaParser.BodyContext context)         => new TextBlock(context.GetText());    public override Block VisitEqInt(JinjaParser.EqIntContext context)         => new IntExpression(context.INT().GetText());    public override Block VisitEqVar(JinjaParser.EqVarContext context)         => new IdExpression(context.ID().GetText());    public override Block VisitEqStr(JinjaParser.EqStrContext context)         => new StringExpression(context.STRING().GetText());        public override Block VisitEqDbl(JinjaParser.EqDblContext context)         => new DoubleExpression(context.DOUBLE().GetText());    public override Block VisitEqCollection(JinjaParser.EqCollectionContext context)    {        var values             = context.collection()                .INT()                .Select(value => int.Parse(value.GetText()))                .Cast<object>()                .ToArray();                return new CollectionExpression(values);    }    public override Block VisitEqCollectionAccessor(JinjaParser.EqCollectionAccessorContext context)    {        var accessor = context.collection_accessor();        var name = accessor.ID().GetText();        var accessorValue = accessor.INT().GetText();        return new CollectionAccessorExpression(name, int.Parse(accessorValue));    }    public override Block VisitMacro_statement(JinjaParser.Macro_statementContext context)    {        var fragment = Visit(context.macro_fragement()) as MacroFragmentBlock;        var blocks = context.code_block().Select(Visit).ToList();        return new MacroBlock(fragment!, blocks);    }    public override Block VisitMacro_fragement(JinjaParser.Macro_fragementContext context)    {        var name = context.ID();        return new MacroFragmentBlock(name.GetText());    }}internal struct Context{    public StringBuilder Content = new();    public Dictionary<string, ExpressionBlock> Variables = new();    public Dictionary<string, List<ExpressionBlock>> Macros = new();    public Context() { }}internal interface IRender{    public void Render(Context ctx);}internal abstract class Block{}internal class MacroBlock(MacroFragmentBlock fragmentBlock, List<Block> blocks) : Block, IRender{    private readonly List<Block> Blocks = blocks;        public void Render(Context ctx)    {        var macroContext = new Context();        foreach (var block in Blocks)            if (block is IRender renderer)                renderer.Render(macroContext);    }}internal class MacroFragmentBlock(string name) : Block {}internal class IfBlock(IfFragmentBlock[] fragment, Block? @else) : Block{    public IfFragmentBlock[] Fragment { get; set; } = fragment;    public Block? Else { get; set; } = @else;}internal class IfFragmentBlock : Block{    public BooleanBlock Block { get; set; }}internal class BooleanBlock : Block{}internal class TextBlock(string text) : Block, IRender{    public void Render(Context ctx)         => ctx.Content.Append(text);}internal class AssignmentBlock(string name, ExpressionBlock value) : Block, IRender{    public void Render(Context ctx)         => ctx.Variables.TryAdd(name, value);}internal class EvaluationBlock(ExpressionBlock value) : Block, IRender{    public void Render(Context ctx)    {        if (value is IRender renderable)        {            renderable.Render(ctx);        }    }}internal abstract class ExpressionBlock : Block{    public abstract object? GetValue(Context ctx);};public enum Operator{    Add,Subtract,Mul,Div}internal class AddSubExpressionBlock(ExpressionBlock left, ExpressionBlock right, Operator @operator)     : ExpressionBlock    , IRender{    public ExpressionBlock Left = left;    public ExpressionBlock Right = right;    public Operator OperatorType = @operator;    public override object? GetValue(Context ctx)    {        var leftValue = Left.GetValue(ctx);        var rightValue = Right.GetValue(ctx);        return (leftValue, rightValue, OperatorType) switch        {            (int lVal, int rVal, Operator.Add) => lVal + rVal,            (int lVal, int rVal, Operator.Subtract) => lVal - rVal,            (int lVal, int rVal, Operator.Mul) => lVal * rVal,            (int lVal, int rVal, Operator.Div) => lVal / rVal,                        (string lVal, int rVal, Operator.Add) => $"{lVal}{rVal}",            (int lVal, string rVal, Operator.Add) => $"{lVal}{rVal}",            (string lVal, string rVal, Operator.Add) => $"{lVal}{rVal}",                        (double lVal, double rVal, Operator.Add) => lVal + rVal,            (double lVal, double rVal, Operator.Subtract) => lVal - rVal,            (double lVal, double rVal, Operator.Mul) => lVal * rVal,            (double lVal, double rVal, Operator.Div) => lVal / rVal,                        (int lVal, double rVal, Operator.Add) => lVal + rVal,            (int lVal, double rVal, Operator.Subtract) => lVal - rVal,            (int lVal, double rVal, Operator.Mul) => lVal * rVal,            (int lVal, double rVal, Operator.Div) => lVal / rVal,                        (double lVal, int rVal, Operator.Add) => lVal + rVal,            (double lVal, int rVal, Operator.Subtract) => lVal - rVal,            (double lVal, int rVal, Operator.Mul) => lVal * rVal,            (double lVal, int rVal, Operator.Div) => lVal / rVal,                        _ => throw new ArgumentOutOfRangeException()        };    }    public void Render(Context ctx)         => ctx.Content.Append(GetValue(ctx));}internal class IdExpression(string name) : ExpressionBlock, IRender{    public override object? GetValue(Context ctx)         => ctx.Variables.GetValueOrDefault(name);    public void Render(Context ctx)    {        if (!ctx.Variables.TryGetValue(name, out var value))        {            return;        }        ctx.Content.Append(value.GetValue(ctx));    }}internal class IntExpression(string getText) : ExpressionBlock{    private int Value { get; } = int.Parse(getText);    public override object GetValue(Context ctx) => Value;}internal class StringExpression(string getText) : ExpressionBlock, IRender{    private string Value { get; } = getText;    public override object GetValue(Context ctx) => Value;        public void Render(Context ctx)         => ctx.Content.Append(Value);}internal class DoubleExpression(string getText) : ExpressionBlock{    private double Value { get; } = double.Parse(getText);    public override object GetValue(Context ctx) => Value;}internal class CollectionExpression(object[] values) : ExpressionBlock{    public object[] Value { get; } = values;    public override object GetValue(Context ctx) => Value;}internal class CollectionAccessorExpression(string name, int accessor) : ExpressionBlock, IRender{    private string Name { get; } = name;    private int Accessor { get; } = accessor;    public override object GetValue(Context ctx)    {        if(!ctx.Variables.TryGetValue(Name, out var value ))        {            return null;        }        return value is not CollectionExpression collection             ? null :            collection.Value[Accessor];    }    public void Render(Context ctx)    {        ctx.Content.Append(GetValue(ctx));    }}