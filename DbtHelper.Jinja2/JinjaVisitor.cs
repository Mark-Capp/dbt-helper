using System.Text;namespace DbtHelper.Jinja2;internal class JinjaVisitor : JinjaParserBaseVisitor<List<Block>>{    public override List<Block> VisitProgram(JinjaParser.ProgramContext context)    {        var blocks = new List<Block>();                var visitor = new ExpressionVisitor();        var statements = context.statement();        foreach (var statement in statements)             blocks.AddRange(visitor.Visit(statement));                return blocks;    }}internal class ExpressionVisitor : JinjaParserBaseVisitor<Block>{    public override Block VisitAssignment_statement(JinjaParser.Assignment_statementContext context)    {        var name = context.ID().GetText();        var expression = Visit(context.expression()) as ExpressionBlock;        return new AssignmentBlock(name, expression!);    }    public override Block VisitEvaluation_statement(JinjaParser.Evaluation_statementContext context)    {        var expression = Visit(context.expression()) as ExpressionBlock;        return new EvaluationBlock(expression!);    }    public override Block VisitEqAdd(JinjaParser.EqAddContext context)    {        var left = Visit(context.left) as ExpressionBlock;        var right = Visit(context.left) as ExpressionBlock;        if (left == null || right == null)        {            return null;        }        return new AddSubExpressionBlock(left, right, context.@operator.TokenIndex == JinjaParser.ADD ? Operator.Add :            Operator.Subtract);    }    public override Block VisitEqMUL(JinjaParser.EqMULContext context)    {        var left = Visit(context.left) as ExpressionBlock;        var right = Visit(context.left) as ExpressionBlock;        if (left == null || right == null)        {            return null;        }        return new AddSubExpressionBlock(left, right, context.@operator.TokenIndex == JinjaParser.MUL ? Operator.Mul :            Operator.Div);    }    public override Block VisitEqInt(JinjaParser.EqIntContext context)         => new IntExpression(context.INT().GetText());    public override Block VisitEqVar(JinjaParser.EqVarContext context)         => new IdExpression(context.ID().GetText());    public override Block VisitEqStr(JinjaParser.EqStrContext context)         => new StringExpression(context.STRING().GetText());        public override Block VisitEqDbl(JinjaParser.EqDblContext context)         => new DoubleExpression(context.DOUBLE().GetText());    public override Block VisitMacro_statement(JinjaParser.Macro_statementContext context)    {        var fragment = Visit(context.macro_fragement()) as MacroFragmentBlock;        var blocks = context.code_block().Select(Visit).ToList();        return new MacroBlock(fragment!, blocks);    }    public override Block VisitMacro_fragement(JinjaParser.Macro_fragementContext context)    {        var name = context.ID();        return new MacroFragmentBlock(name.GetText());    }}internal struct Context{    public StringBuilder Content = new();    public Dictionary<string, ExpressionBlock> Variables = new();    public Dictionary<string, List<ExpressionBlock>> Macros = new();    public Context() { }}internal abstract class Block{    public abstract void Render(Context ctx);}internal class MacroBlock(MacroFragmentBlock fragmentBlock, List<Block> blocks) : Block{    private readonly List<Block> Blocks = blocks;        public override void Render(Context ctx)    {        var macroContext = new Context();        foreach (var block in Blocks)             block.Render(macroContext);    }}internal class MacroFragmentBlock(string name) : Block{        public override void Render(Context ctx)    {    }}internal class IfBlock(IfFragmentBlock[] fragment, Block? @else) : Block{    public IfFragmentBlock[] Fragment { get; set; } = fragment;    public Block? Else { get; set; } = @else;        public override void Render(Context ctx)    {            }}internal class IfFragmentBlock : Block{    public BooleanBlock Block { get; set; }    public override void Render(Context ctx)    {        throw new NotImplementedException();    }}internal class BooleanBlock : Block{    public override void Render(Context ctx)    {            }}internal class TextBlock(string text) : Block{    public override void Render(Context ctx)         => ctx.Content.Append(text);}internal class AssignmentBlock(string name, ExpressionBlock value) : Block{    public override void Render(Context ctx)         => ctx.Variables.TryAdd(name, value);}internal class EvaluationBlock(ExpressionBlock value) : Block{    public override void Render(Context ctx)    {        value.Render(ctx);    }}internal abstract class ExpressionBlock : Block{    public abstract object? GetValue(Context ctx);};public enum Operator{    Add,Subtract,Mul,Div}internal class AddSubExpressionBlock(ExpressionBlock left, ExpressionBlock right, Operator @operator) : ExpressionBlock{    public ExpressionBlock Left = left;    public ExpressionBlock Right = right;    public Operator OperatorType = @operator;        public override void Render(Context ctx)    {        throw new NotImplementedException();    }    public override object? GetValue(Context ctx)    {        var leftValue = Left.GetValue(ctx);        var rightValue = Right.GetValue(ctx);        return 1;    }}internal class IdExpression(string name) : ExpressionBlock{    public override object? GetValue(Context ctx)    {        return ctx.Variables.GetValueOrDefault(name);    }    public override void Render(Context ctx)    {        if (!ctx.Variables.TryGetValue(name, out var value))        {            return;        }        ctx.Content.Append(value);    }}internal class IntExpression(string getText) : ExpressionBlock{    public int Value { get; } = int.Parse(getText);            public override void Render(Context ctx)    {    }    public override object GetValue(Context ctx) => Value;}internal class StringExpression(string getText) : ExpressionBlock{    public string Value { get; } = getText;            public override void Render(Context ctx)    {    }    public override object GetValue(Context ctx) => Value;}internal class DoubleExpression(string getText) : ExpressionBlock{    public double Value { get; } = double.Parse(getText);            public override void Render(Context ctx)    {    }    public override object GetValue(Context ctx) => Value;}