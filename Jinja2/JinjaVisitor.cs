namespace Jinja2;internal class JinjaVisitor : JinjaParserBaseVisitor<List<Block>>{    public override List<Block> VisitTemplate(JinjaParser.TemplateContext context)    {        var blocks = new List<Block>();        var visitor = new ExpressionVisitor();        var statements = context.children;        foreach (var statement in statements)             blocks.AddRange(visitor.Visit(statement));                return blocks;    }}internal class ExpressionVisitor : JinjaParserBaseVisitor<Block>{    public override Block VisitText(JinjaParser.TextContext context)        => new TextBlock(context.GetText());    public override Block VisitExpression(JinjaParser.ExpressionContext context)         => Visit(context.expression_body());    public override Block VisitEqAssign(JinjaParser.EqAssignContext context)    {        var name = context.ID().GetText();        var expression = Visit(context.expression_body()) as ExpressionBlock;        return new SetBlock(name, expression!);    }    public override Block VisitEqAdd(JinjaParser.EqAddContext context)    {        var left = Visit(context.left) as ExpressionBlock;        var right = Visit(context.right) as ExpressionBlock;                return new MathBlock(left, right,            context.@operator.Type == JinjaLexer.PLUS ? Operator.Add : Operator.Subtract);    }        public override Block VisitEqMul(JinjaParser.EqMulContext context)    {        var left = Visit(context.left) as ExpressionBlock;        var right = Visit(context.right) as ExpressionBlock;                return new MathBlock(left, right,            context.@operator.Type == JinjaLexer.MUL ? Operator.Mul : Operator.Div);    }    public override Block VisitEqINT(JinjaParser.EqINTContext context)         => new IntBlock(int.Parse(context.INT().GetText()));        public override Block VisitEqID(JinjaParser.EqIDContext context)         => new IdBlock(context.ID().GetText());}public abstract class Block;public enum Operator{    Add, Subtract, Mul, Div,    GreaterThan, LessThan, GreaterThanOrEqual, LessThanOrEqual, Equal, NotEqual,    And, Or, Not,}public abstract class ExpressionBlock : Block{    public abstract object? GetValue(Context context);}public class TextBlock(string content)     : Block, IRender{    public void Render(Context context)         => context.Content += content;}public class SetBlock(string name, ExpressionBlock value) : Block, IRender{    public void Render(Context context)         => context.Variables.TryAdd(name, value);}public class IdBlock(string name) : ExpressionBlock, IRender{    public void Render(Context context)    {        if (!context.Variables.TryGetValue(name, out var value))        {            return;        }        context.Content += value.GetValue(context);    }    public override object? GetValue(Context context)         => !context.Variables.TryGetValue(name, out var value) ? null : value.GetValue(context);    public object? Add(Context context, ExpressionBlock block)    {        if (!context.Variables.TryGetValue(name, out var value))        {            return null;        }                var command = new AddCommand(value, block);        return command.Execute(context);    }}public class IntBlock(int value) : ExpressionBlock{    public override object GetValue(Context context) => value;    public int Add(Context context, IntBlock block)    {        var right = block.GetValue(context) as int? ?? 0;        return value + right;    }        public int Mul(Context context, IntBlock block)    {        var right = block.GetValue(context) as int? ?? 0;        return value * right;    }        public int Sub(Context context, IntBlock block)    {        var right = block.GetValue(context) as int? ?? 0;        return value - right;    }        public int Div(Context context, IntBlock block)    {        var right = block.GetValue(context) as int? ?? 0;        return value / right;    }}public class MathBlock(    ExpressionBlock left,    ExpressionBlock right,    Operator @operator) : ExpressionBlock, IRender{    public override object? GetValue(Context context)    {        ICommand command = @operator switch        {            Operator.Add => new AddCommand(left, right),            Operator.Subtract => new SubCommand(left, right),            Operator.Mul => new MulCommand(left, right),            Operator.Div => new DivCommand(left, right),            _ => new NoOpCommand()         };        return command.Execute(context);    }    public void Render(Context context) => context.Content+= GetValue(context);}public class Context{   public string Content { get; set; } = "";    public Dictionary<string, ExpressionBlock> Variables { get; set; } = new();}public interface IRender{    void Render(Context context);}public interface ICommand{    object? Execute(Context context);}public class AddCommand(ExpressionBlock left, ExpressionBlock right) : ICommand{    public object? Execute(Context context)    {        var tuple = (left, right);        return tuple switch        {            (IntBlock leftInt, IntBlock rightInt) => leftInt.Add(context, rightInt),            (IdBlock leftInt, { } r) => leftInt.Add(context, r),            ({} l, IdBlock r) => r.Add(context, l),            (_, _) => 0        };    }}public class MulCommand(ExpressionBlock left, ExpressionBlock right) : ICommand{    public object? Execute(Context context)    {        var tuple = (left, right);        return tuple switch        {            (IntBlock leftInt, IntBlock rightInt) => leftInt.Mul(context, rightInt),            (_, _) => 0        };    }}public class SubCommand(ExpressionBlock left, ExpressionBlock right) : ICommand{    public object? Execute(Context context)    {        var tuple = (left, right);        return tuple switch        {            (IntBlock leftInt, IntBlock rightInt) => leftInt.Sub(context, rightInt),            (_, _) => 0        };    }}public class DivCommand(ExpressionBlock left, ExpressionBlock right) : ICommand{    public object? Execute(Context context)    {        var tuple = (left, right);        return tuple switch        {            (IntBlock leftInt, IntBlock rightInt) => leftInt.Div(context, rightInt),            (_, _) => 0        };    }}public class NoOpCommand : ICommand{    public object? Execute(Context context) => null;}